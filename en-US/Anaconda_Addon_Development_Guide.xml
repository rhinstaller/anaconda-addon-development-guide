<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
<!ENTITY % BOOK_ENTITIES SYSTEM "Anaconda_Addon_Development_Guide.ent">
%BOOK_ENTITIES;
]>
<article>
  <xi:include href="Article_Info.xml" xmlns:xi="http://www.w3.org/2001/XInclude" />
  <section id="sect-anaconda-addon-introduction">
    <title>Introduction to Anaconda and Add-ons</title>
  
    <section id="sect-anaconda-introduction">
      <title>Introduction to Anaconda</title>
      <para>
        <application>Anaconda</application> is the operating system installer used in Fedora,
        Red&nbsp;Hat Enterprise&nbsp;Linux, and their derivatives. It is a set of Python modules and
        scripts together with some additional files like <systemitem>Gtk</systemitem> widgets
        (written in C), <systemitem>systemd</systemitem> units, and <systemitem>dracut</systemitem>
        libraries. Together, they form a tool that allows users to set parameters of the resulting
        (target) system and then set such a system up on a machine. The installation process has
        four major steps:
      </para>
      <itemizedlist>
        <listitem>
          <para>
            installation destination preparation (usually disk partitioning)
          </para>
        </listitem>
        <listitem>
          <para>
            package and data installation
          </para>
        </listitem>
        <listitem>
          <para>
            boot loader installation and configuration
          </para>
        </listitem>
        <listitem>
          <para>
            configuration of the newly installed system
          </para>
        </listitem>
      </itemizedlist>
      <para>
        There are three ways you can control the installer and specify installation options. The
        most common approach is to use the <firstterm>graphical user interface</firstterm> (GUI).
        This interface is meant to allow users to install the system interactively with little or no
        configuration required before beginning the installation, and it should cover all common use
        cases, including setting up complicated partitioning layouts.
      </para>
      <para>
        The graphical interface also supports remote access over <systemitem>VNC</systemitem>, which
        allows you to use the GUI even on systems with no graphics cards or even attached monitor.
        However, there are still cases where this is not desired, but at the same time, you may want
        to perform an interactive installation. For these cases, a <firstterm>text mode</firstterm>
        (TUI) is available. The TUI works in a way similar to a monochrome line printer, which
        allows it to work even on serial consoles which do not support cursor movement, colors and
        other advanced features. The text mode is limited in that it only allows you to customize
        most common options, such as network settings, language options or installation (package)
        source; advanced features such as manual partitioning are not available in this interface.
      </para>
      <para>
        The third way to install a system using <application>Anaconda</application> is by using a
        Kickstart file - a plain text file with shell-like syntax which can contain data to drive
        the installation process. A Kickstart file allows you to partially or completely automate
        the installation. A certain set of commands which configures all required areas is necessary
        to completely automate the installation; if one or more of the required commands is missing,
        the installation will require interaction. If all required commands are present, the
        installation will be performed in a completely automatic way, without any need for
        interaction.
      </para>
      <para>
        Kickstart provides the highest amount of options, covering use cases where neither the TUI
        nor the GUI is sufficient. Every feature in <application>Anaconda</application> must always
        be supported in Kickstart; other interfaces follow only subsets of all available options,
        which allows them to remain clear.
      </para>
    </section>

    <section id="sect-firstboot-introduction">
      <title>Firstboot and Initial Setup</title>
      <para>
        The first boot of the newly installed system is traditionally considered a part of the
        installation process as well, because some parts of configuration such as user creation are
        often performed at this point. In older releases of Red&nbsp;Hat Enterprise&nbsp;Linux, the
        <application>Firstboot</application> tool has been used for this purpose, allowing you to
        register your newly installed system or configure <application>Kdump</application>. However,
        <application>Firstboot</application> relies on no longer maintained tools such as
        <systemitem>Gtk2</systemitem> and the <systemitem>pygtk2</systemitem> module. 
        <footnote>
          <para>
            While Firstboot is a legacy tool, it is still supported because of third-party modules
            written for it.
          </para>  
        </footnote> 
        For this reason, a new tool called <application>Initial Setup</application> was developed,
        which reuses code from <application>Anaconda</application>. This allows add-ons developed
        for <application>Anaconda</application> to be easily reused in <application>Initial
          Setup</application>. This topic is further discussed in <xref
          linkend="sect-writing-anaconda-addon" />.
      </para>
    </section>
    
    <section id="sect-anaconda-introduction-addons">
      <title>Anaconda and Initial Setup Add-ons</title>
      <para>
        Installing a new operating system is a vastly complicated use case - each user may want to
        do something slightly different. Designing an installer for every corner case would cause it
        to be cluttered with rarely-used functionality. For this reason, when the installer was
        being rewritten into its current form, it gained support for add-ons.
      </para>
      <para>
        <application>Anaconda</application> add-ons can be used to add your own Kickstart commands
        and options as well as new configuration screens in the graphical and text-based user
        interface, depending on your specific use case. Each add-on must have Kickstart support; the
        GUI and TUI are optional, but can be very helpful.
      </para>
      <para>
        In current releases of Fedora
        <footnote>
          <para>
            In Fedora, the add-on is disabled by default. You can enable it using the
            <option>inst.kdump_addon=on</option> option in the boot menu.
          </para>
        </footnote>
        (21 and later) and Red&nbsp;Hat Enterprise&nbsp;Linux (7.1 and later), one add-on is
        included by default: The <application>Kdump</application> add-on, which adds support for
        configuring kernel crash dumping during the installation. This add-on has full support in
        Kickstart (using the <command>%addon com_redhat_kdump</command> command and its options) and
        is fully integrated as an additional screen in the text-based and graphical interfaces. You
        can develop other add-ons in the same way and add them to the default installer using
        procedures described further in this guide.
      </para>
    </section>
    
    <section id="sect-anaconda-introduction-additional-information">
      <title>Additional Information</title>
      <para>
        Following links contain additional information about <application>Anaconda</application> and
        <application>Initial Setup</application>:
      </para>
      <itemizedlist>
        <listitem>
          <para>
            The <ulink
              url="https://anaconda-installer.readthedocs.io/">Anaconda documentation</ulink>
            and <ulink
              url="http://fedoraproject.org/wiki/Anaconda">Anaconda page on Fedora Project Wiki</ulink>
            provides more information about the installer.
          </para>
        </listitem>
        <listitem>
          <para>
           Chapters <ulink
             url="https://docs.fedoraproject.org/en-US/Fedora/&PRODVER;/html/Installation_Guide/chap-kickstart-installations.html">Automating
             the Installation with Kickstart</ulink> and <ulink
             url="https://docs.fedoraproject.org/en-US/Fedora/&PRODVER;/html/Installation_Guide/appe-kickstart-syntax-reference.html">Kickstart
             Syntax Reference</ulink> of the <citetitle>Fedora Installation Guide</citetitle>
           contain documentation of Kickstart. <ulink
             url="http://pykickstart.readthedocs.io">Pykickstart documentation</ulink> provides
           a list of all supported commands and options.
          </para>
        </listitem>
        <listitem>
          <para>
            The <ulink
              url="https://docs.fedoraproject.org/en-US/Fedora/&PRODVER;/html/Installation_Guide/chap-installing-using-anaconda.html">Installing
              Using Anaconda</ulink> chapter of the <citetitle>Fedora Installation Guide</citetitle>
            describes the installation process in the graphical and text user interfaces.
          </para>
        </listitem>
        <listitem>
          <para>
            For information about tools used for after-installation configuration, see <ulink
              url="https://docs.fedoraproject.org/en-US/Fedora/&PRODVER;/html/Installation_Guide/chap-after-installation.html#sect-initial-setup">Initial
              Setup</ulink>.
          </para> 
        </listitem>
      </itemizedlist>
    </section>

  </section>

  <section id="sect-anaconda-addon-architecture">
    <title>Architecture of Anaconda</title>
    <para>
      <application>Anaconda</application> is a set of Python modules and scripts. It also uses
      several external packages and libraries, some of which were created specifically for the
      installer. Major components of this toolset include the following packages:
    </para>
    <itemizedlist>
      <listitem>
        <para>
          <systemitem>pykickstart</systemitem> - used to parse and validate Kickstart files and also
          to provide a data structure which stores values which drive the installation
        </para>
      </listitem>
      <listitem>
        <para>
          <systemitem>dnf</systemitem> or <systemitem>yum</systemitem> - the package manager which
          handles installation of packages and resolving dependencies
        </para>
      </listitem>
      <listitem>
        <para>
          <systemitem>blivet</systemitem> - originally split from the <package>anaconda</package>
          package as <package>pyanaconda.storage</package>; used to handle all activities related to
          storage management
        </para>
      </listitem>
      <listitem>
        <para>
          <systemitem>pyanaconda</systemitem> - package containing the core of the user interface
          and modules for functionality unique to <application>Anaconda</application>, such as
          keyboard and timezone selection, network configuration, and user creation, as well as a
          number of utilities and system-oriented functions
        </para>
      </listitem>
      <listitem>
        <para>
          <systemitem>python-meh</systemitem> - contains an exception handler which gathers and
          stores additional system information in case of a crash and passes this information to the
          <systemitem>libreport</systemitem> library, which itself is a part of the <ulink
            url="https://fedorahosted.org/abrt/">ABRT Project</ulink>.
        </para>
      </listitem>
    </itemizedlist>
    <para>
      The life cycle of data during the installation process is straightforward. If a Kickstart file
      is provided, it is processed by the <systemitem>pykickstart</systemitem> module and imported
      into memory as a tree-like structure. If no Kickstart file is provided, an empty tree-like
      structure is created instead. If the installation is interactive (not all required Kickstart
      commands have been used), the structure is then updated with choices made by the user in the
      interactive interface. 
    </para>
    <para>
      Once all required choices are made, the installation process begins and values stored in the
      structure are used to determine parameters of the installation. The values are also written as
      a Kickstart file which is saved in the <filename>/root/</filename> directory on the installed
      system; therefore the installation can be replicated automatically by reusing this
      automatically generated Kickstart file.
    </para>
    <para>
      Elements of the tree-like structure are defined by the <package>pykickstart</package> package,
      but some of them can be overriden by modified versions from the
      <systemitem>pyanaconda.kickstart</systemitem> module. An important rule which governs this
      behavior is that there is no place to store configuration data, and the installation process
      is data-driven and relies on transactions as much as possible. This enforces the following
      features:
    </para>
    <itemizedlist>
      <listitem>
        <para>
          every feature of the installer <emphasis>must</emphasis> be supported in Kickstart
        </para>
      </listitem>    
      <listitem>
        <para>
          there is a single, obvious point in the installation process where changes are written to
          the target system; before this point, no lasting changes (e.g. formatting storage) are
          made
        </para>
      </listitem>
      <listitem>
        <para>
          every change made manually in the user interface is reflected in the resulting Kickstart
          file and can be replicated
        </para>
      </listitem>
    </itemizedlist>
    <para>
      The fact that the installation is <emphasis>data-driven</emphasis> means that installation and
      configuration logic lies within the methods of the items in the tree-like structure. Every
      item is set up (the <methodname>setup</methodname> method) to modify the runtime environment
      of the installation if necessary, and then executed (the <methodname>execute</methodname>
      method) to perform the changes on the target system. These methods are further described in
      <xref linkend="sect-writing-anaconda-addon" />.
    </para>
  </section>

  <section id="sect-anaconda-hub-and-spoke">
    <title>The Hub &amp; Spoke model</title>
    <para>
      One of the notable differences between <application>Anaconda</application> and most other
      operating system installers is its non-linear nature, also known as the <firstterm>hub and
        spoke</firstterm> model.
    </para>
    <para>
      The hub and spoke model of <application>Anaconda</application> has several advantages,
      including:
    </para>
    <itemizedlist>
      <listitem>
        <para>
          users are not forced to go through the screens in some strictly defined order
        </para>
      </listitem>
      <listitem>
        <para>
          users are not forced to visit every screen no matter if they understand what the options
          configured in it mean or not
        </para>
      </listitem>
      <listitem>
        <para>
          it is good for the transactional mode where all desired values can be set while nothing is
          actually happening to the underlying machine  until a special button is clicked
        </para>
      </listitem>
      <listitem>
        <para>
          it provides way to show an overview of the configured values
        </para>
      </listitem>
      <listitem>
        <para>
          it has a great support for extensibility, because additional spokes  can be put on hubs
          without need to reorder anything and resolve some complex ordering dependencies
        </para>
      </listitem>
      <listitem>
        <para>
          it can be used for both graphical and text mode of the installer
        </para>
      </listitem>
    </itemizedlist>
    <para>
      The diagram below shows the installer layout as well as possible interactions between
      <firstterm>hubs</firstterm> and <firstterm>spokes</firstterm> (screens):
    </para>
    <figure id="figu-anaconda-hub-and-spoke">
      <title>Diagram of the hub and spoke model</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/hub_and_spoke.svg" format="SVG" scalefit="0" width="660"/>
        </imageobject>
      </mediaobject>
    </figure>
    <para>
      In the diagram, screens 2-13 are called <firstterm>normal spokes</firstterm>, and screens 1
      and 14 are <firstterm>standalone spokes</firstterm>. Standalone spokes are a type of screen
      which is a type of screen that should be used only in case it has to be visited before (or
      after) the following (or previous) standalone spoke or hub. This may be, for example, the
      <guilabel>Welcome</guilabel> screen at the beginning of the installation which prompts you to
      choose your language for the rest of the installation.
    </para>
    <note>
      <para>
        Screens mentioned in the rest of this section are screens from the installer's graphical
        interface (GUI).
      </para>
    </note>
    <para>
      Central points of the hub and spoke model are <firstterm>hubs</firstterm>. There are two hubs
      by default:
    </para>
    <itemizedlist>
      <listitem>
        <para>
          The <guilabel>Installation Summary</guilabel> hub which shows a summary of configured
          options before the installation begins
        </para>
      </listitem>
      <listitem>
        <para>
          The <guilabel>Configuration and Progress</guilabel> hub which appears after you click
          <guilabel>Begin Installation</guilabel> in <guilabel>Installation Summary</guilabel>, and
          which displays the progress of the installation process and allows you to configure
          additional options (set the root password and create a user account).
        </para>
      </listitem>
    </itemizedlist>
    <para>
      Each spoke has several predefined <firstterm>properties</firstterm> which are reflected on the
      hub. These are:
    </para>
    <itemizedlist>
      <listitem>
        <para>
          <property>ready</property> - states whether the spoke can be visited or not; for example,
          when the installer is configuring a package source, that spoke is not ready, is colored
          gray, and cannot be accessed until configuration is complete
        </para>
      </listitem>
      <listitem>
        <para>
          <property>completed</property> - marks the spoke as completed (all required values are
          set) or not
        </para>
      </listitem>
      <listitem>
        <para>
          <property>mandatory</property> - determines whether the spoke <emphasis>must</emphasis> be
          visited and confirmed by the user before continuing the installation; for example, the
          <guilabel>Installation Destination</guilabel> spoke must always be visited, even if you
          want to use automatic disk partitioning
        </para>
      </listitem>
      <listitem>
        <para>
          <property>status</property> - provides a short summary of values configured within the
          spoke (displayed under the spoke name in the hub)
        </para>
      </listitem>
    </itemizedlist>
    <para>
      To make the user interface clearer, spokes are grouped together into
      <firstterm>categories</firstterm>. For example, the <guilabel>Localization</guilabel> category
      groups together spokes for keyboard layout selection, language support and time zone settings.
    </para>
    <para>
      Each spoke contains UI controls which display and allow you to modify values from one or more
      sub-trees of the in-memory tree-like structure which was discussed in <xref
        linkend="sect-anaconda-addon-architecture" />. As <xref
        linkend="sect-writing-anaconda-addon" /> explains, the same applies to spokes provided by
      add-ons.
    </para>
  </section>

  <section id="sect-anaconda-threads-communication">
    <title>Threads and Communication</title>
    <para>
      Some of the actions which need to be performed during the installation process, such as
      scanning disks for existing partitions or downloading package metadata, can take a long time.
      To prevent you from waiting and remain responsive if possible,
      <application>Anaconda</application> runs these actions in separate threads.
    </para>
    <para>
      The <application>Gtk</application> toolkit does not support element changes from multiple
      threads. The main event loop of <application>Gtk</application> runs in the main thread of the
      <application>Anaconda</application> process itself, and all code performing actions which
      involve the GUI must make sure that these actions are run in the main thread as well. The only
      supported way to do so is by using the <methodname>GLib.idle_add</methodname>, which is not
      always easy or desired. To alleviate this problem, several helper functions and decorators are
      defined in the <package>pyanaconda.ui.gui.utils</package> module.
    </para>
    <para>
      The most useful of those are the <function>@gtk_action_wait</function> and
      <function>@gtk_action_nowait</function> decorators. They change the decorated function or
      method in such a way that when this function or method is called, it is automatically queued
      into Gtk's main loop, run in the main thread, and the return value is either returned to the
      caller or dropped, respectively.
    </para>
    <para>
      As mentioned previously, one of the main reasons for using multiple threads is to allow the
      user to configure some screens while other screens which are currently busy (such as
      <guilabel>Installation Source</guilabel> when it downloads package metadata) configure
      themselves. Once the configuration is finished, the spoke which was previously busy needs to
      announce that it is now ready and not blocked; this is handled by a message queue called
      <systemitem>hubQ</systemitem>, which is being periodically checked in the main event loop.
      When a spoke becomes accessible, it sends a message to this queue announcing this change and
      that it should no longer be blocked.
    </para>
    <para>
      The same applies in a situation where a spoke needs to refresh its status or completion flag.
      The <guilabel>Configuration and Progress</guilabel> hub has a different queue called
      <systemitem>progressQ</systemitem> which serves as a medium to transfer installation progress
      updates.
    </para>
    <para>
      These mechanisms are also needed for the text-based interface, where the situation is more
      complicated; there is no main loop in text mode, instead the majority of time in this mode is
      spent waiting for keyboard input.
    </para>
  </section>

  <section id="sect-anaconda-addon-structure">
    <title>Anaconda Add-on Structure</title>
    <para>
      An <application>Anaconda</application> add-on is a Python package containing a directory with
      an <filename>__init__.py</filename> and other source directories (subpackages) inside. Because
      Python allows importing each package name only once, the package top-level directory name must
      be unique. At the same time, the name can be arbitrary, because add-ons are loaded regardless
      of their name - the only requirement is that they must be placed in a specific directory. 
    </para>
    <para>
      The suggested naming convention for add-ons is therefore similar to Java packages or D-Bus
      service names: prefix the add-on name with the reversed domain name of your organization,
      using underscores (<literal>_</literal>) instead of dots so that the directory name is a valid
      identifier for a Python package. An example add-on name following these suggestions would
      therefore be e.g. <literal>org_fedora_hello_world</literal>. This convention follows the
      <ulink url="https://www.python.org/dev/peps/pep-0008/#package-and-module-names">recommended
        naming scheme</ulink> for Python package and module names.
    </para>
    <important>
      <para>
        Make sure to create an <filename>__init__.py</filename> file in each directory. Directories
        missing this file are not considered valid Python packages.
      </para>
    </important>
    <para>
      When writing an add-on, keep in mind that every function supported in the installer
      <emphasis>must</emphasis> be supported in Kickstart; GUI and TUI support is optional. Support
      for each interface (Kickstart, graphical interface and text interface) must be in a separate
      subpackage and these subpackages must be named <filename>ks</filename> for Kickstart,
      <filename>gui</filename> for the graphical interface and <filename>tui</filename> for the
      text-based interface. The <filename>gui</filename> and <filename>tui</filename> packages must
      also contain a <filename>spokes</filename> subpackage.
      <footnote>
        <para>
          The <package>gui</package> package may also contain a <package>categories</package>
          subpackage if the add-on needs to define a new category, but this is not recommended.
        </para>
      </footnote>
    </para>
    <para>
      Names of modules inside these packages are arbitrary; the <filename>ks/</filename>,
      <filename>gui/</filename> and <filename>tui/</filename> directories can contain Python modules
      with any name.
    </para>
    <para>
      A sample directory structure for an add-on which supports every interface (Kickstart, GUI and
      TUI) will look similar to the following:
    </para>
    <example id="exam-sample-addon-structure">
      <title>Sample Add-on Structure</title>
      <screen>
org_fedora_hello_world
├─ ks
│  └─ __init__.py
├─ gui
│  ├─ __init__.py
│  └─ spokes
│      └─ __init__.py
└─ tui
   ├─ __init__.py
   └─ spokes
       └─ __init__.py
      </screen>
    </example>
    <para>
      Each package must contain at least one module with an arbitrary name defining classes
      inherited from one or more classes defined in the API. This is further discussed in <xref
        linkend="sect-writing-anaconda-addon" />.
    </para>
    <para>
      All add-ons should follow Python's <ulink url="http://www.python.org/dev/peps/pep-0008/">PEP
        8</ulink> and <ulink url="http://www.python.org/dev/peps/pep-0257/">PEP 257</ulink>
      guidelines for docstring conventions. There is no consensus on the format of the actual
      content of docstrings in <application>Anaconda</application>; the only requirement is that
      they are human-readable. If you plan to use automatically generated documentation for your
      add-on, docstrings should follow the guidelines for the toolkit you use to accomplish this.
    </para>
  </section>

  <section id="sect-writing-anaconda-addon">
    <title>Writing an Anaconda add-on</title>
    <para>
      The sections below will demonstrate the process writing and testing a sample add-on called
      Hello World. This sample add-on will support all interfaces (Kickstart, GUI and TUI). Sources
      for this sample add-on are available on GitHub in the <ulink
        url="https://github.com/rhinstaller/hello-world-anaconda-addon">rhinstaller/hello-world-anaconda-addon</ulink>
      repository; it is recommended to clone this repository or at least open the sources in the web
      interface.
    </para>
    <para>
      Another repository to review is <ulink
        url="https://github.com/rhinstaller/anaconda">rhinstaller/anaconda</ulink>, which contains
      the installer source code; it will be referred to in several parts of this section as well.
    </para>
    <para>
      Before you begin developing the add-on itself, start by creating its directory structure as
      described in <xref linkend="sect-anaconda-addon-structure" />. Then, continue with <xref
        linkend="sect-anaconda-addon-kickstart-support" />, as Kickstart support is mandatory for
      all add-ons. After that, you can optionally continue with <xref
        linkend="sect-anaconda-addon-gui-support" /> and <xref
        linkend="sect-anaconda-addon-tui-support" /> if needed.
    </para>

    <section id="sect-anaconda-addon-kickstart-support">
      <title>Kickstart Support</title>
      <para>
        Kickstart support is always the first part of any add-on that should be developed. Other
        packages - support for the graphical and text-based interface - will depend on it. To begin,
        navigate to the <filename>org_fedora_hello_world/ks/</filename> directory you have created
        previously, make sure it contains an <filename>__init__.py</filename> file, and add another
        Python script named <filename>hello_world.py</filename>.
      </para>
      <para>
        Unlike built-in Kickstart commands, add-ons are used in their own
        <firstterm>sections</firstterm>. Each use of an add-on in a Kickstart file begins with an
        <command>%addon</command> statement and is closed by <command>%end</command>. The
        <command>%addon</command> line also contains the name of the add-on (such as <command>%addon
          org_fedora_hello_world</command>) and optionally a list of arguments, if the add-on
        supports them.
      </para>
      <para>
        An example use of an add-on in a Kickstart file looks like the example below:
      </para>
      <example id="exam-addon-kickstart-definition">
        <title>Using an Add-on in a Kickstart File</title>
        <programlisting>
%addon ADDON_NAME [arguments]
first line
second line
...
%end
        </programlisting>
      </example>
      <para>
        The key class for Kickstart support in add-ons is called <classname>AddonData</classname>.
        This class is defined in <package>pyanaconda.addons</package> and represents an object for
        parsing and storing data from a Kickstart file.
      </para>
      <para>
         Arguments are passed as a list to an instance of the add-on class inherited from the
         <classname>AddonData</classname> class. Anything between the first and last line is passed
         to the add-on's class one line at a time. To keep the example Hello World add-on simple, it
         will merge all lines in this block into a single line and separate the original lines with
         a space.
      </para>
      <para>
        The example add-on requires a class inherited from <classname>AddonData</classname> with a
        method for handling the list of arguments from the <command>%addon</command> line, and a
        method for handling lines inside the section. The <ulink
          url="https://github.com/rhinstaller/anaconda/blob/master/pyanaconda/addons.py"><filename>pyanaconda/addons.py</filename></ulink>
        module contains two methods which can be used for this:
      </para>
      <itemizedlist>
        <listitem>
          <para>
            <methodname>handle_header</methodname> - takes a list of arguments from the
            <command>%addon</command> line (and line numbers for error reporting)
          </para>
        </listitem>
        <listitem>
          <para>
            <methodname>handle_line</methodname> - takes a single line of content from between the
            <command>%addon</command> and <command>%end</command> statements
          </para>
        </listitem>
      </itemizedlist>
      <para>
        The example below demonstrates a Hello World add-on which uses the methods described above:
      </para>
      <example id="exam-kickstart-header-line">
        <title>Using handle_header and handle_line</title>
        <programlisting language="Python">from pyanaconda.addons import AddonData
from pykickstart.options import KSOptionParser

# export HelloWorldData class to prevent Anaconda's collect method from taking
# AddonData class instead of the HelloWorldData class
# :see: pyanaconda.kickstart.AnacondaKSHandler.__init__
__all__ = ["HelloWorldData"]

HELLO_FILE_PATH = "/root/hello_world_addon_output.txt"

class HelloWorldData(AddonData):
    """
    Class parsing and storing data for the Hello world addon.

    :see: pyanaconda.addons.AddonData

    """

    def __init__(self, name):
        """
        :param name: name of the addon
        :type name: str

        """

        AddonData.__init__(self, name)
        self.text = ""
        self.reverse = False

    def handle_header(self, lineno, args):
        """
        The handle_header method is called to parse additional arguments in the
        %addon section line.

        :param lineno: the current linenumber in the kickstart file
        :type lineno: int
        :param args: any additional arguments after %addon &lt;name&gt;
        :type args: list
        """

        op = KSOptionParser()
        op.add_option("--reverse", action="store_true", default=False,
                dest="reverse", help="Reverse the display of the addon text")
        (opts, extra) = op.parse_args(args=args, lineno=lineno)

        # Reject any additional arguments.
        if extra:
            msg = "Unhandled arguments on %%addon line for %s" % self.name
            if lineno != None:
                raise KickstartParseError(formatErrorMsg(lineno, msg=msg))
            else:
                raise KickstartParseError(msg)

        # Store the result of the option parsing
        self.reverse = opts.reverse

    def handle_line(self, line):
        """
        The handle_line method that is called with every line from this addon's
        %addon section of the kickstart file.

        :param line: a single line from the %addon section
        :type line: str

        """

        # simple example, we just append lines to the text attribute
        if self.text is "":
            self.text = line.strip()
        else:
            self.text += " " + line.strip()</programlisting>
      </example>
      <para>
        The example begins by importing necessary methods and defining an <varname>__all__</varname>
        variable which is necessary to prevent <application>Anaconda</application>'s collect method
        from taking the <classname>AddonData</classname> class instead of add-on specific
        <classname>HelloWorldData</classname>.
      </para>
      <para>
        Then, the example shows a definition of the <classname>HelloWorldData</classname> class
        inherited from <classname>AddonData</classname> with its <methodname>__init__</methodname>
        method calling the parent's <methodname>__init__</methodname> and initializing the
        attributes <varname>self.text</varname> and <varname>self.reverse</varname> to
        <literal>False</literal>.
      </para>
      <para>
        The <varname>self.reverse</varname> attribute is populated in the
        <methodname>handle_header</methodname> method, and the <varname>self.text</varname> is
        populated in <methodname>handle_line</methodname>. The
        <methodname>handle_header</methodname> method uses an instance of the
        <classname>KSOptionParser</classname> provided by <systemitem>pykickstart</systemitem> to
        parse additional options used on the <command>%addon</command> line, and
        <methodname>handle_line</methodname> strips the content lines of white space at the
        beginning and end of each line, and appends them to <varname>self.text</varname>.
      </para>
      <para>
        The code above covers the first phase of the data life cycle in the installation process: it
        reads data from the Kickstart file. The next step is to use this data to drive the
        installation process. Two predefined methods are available for this purpose:
      </para>
      <itemizedlist>
        <listitem>
          <para>
            <methodname>setup</methodname> - called before the installation transaction starts and
            used to make changes to the installation runtime environment
          </para>
        </listitem>
        <listitem>
          <para>
            <methodname>execute</methodname> - called at the end of the transaction and used to make
            changes to the target system
          </para>
        </listitem>
      </itemizedlist>
      <para>
        To use these two methods, you must add some new imports and a constant to your module, as
        shown in the following example:
      </para>
      <example id="exam-kickstart-setup-execute-prepend">
        <title>Importing the setup and execute Methods</title>
        <programlisting language="Python">import os.path

from pyanaconda.addons import AddonData
from pyanaconda.constants import getSysRoot

from pykickstart.options import KSOptionParser
from pykickstart.errors import KickstartParseError, formatErrorMsg

HELLO_FILE_PATH = "/root/hello_world_addon_output.txt"</programlisting>
      </example>
      <para>
        An updated example of the Hello World add-ons with the <methodname>setup</methodname> and
        <methodname>execute</methodname> methods included is below:
      </para>
      <example id="exam-kickstart-setup-execute">
        <title>Using the setup and execute Methods</title>
        <programlisting language="Python">    def setup(self, storage, ksdata, instclass, payload):
        """
        The setup method that should make changes to the runtime environment
        according to the data stored in this object.

        :param storage: object storing storage-related information
                        (disks, partitioning, bootloader, etc.)
        :type storage: blivet.Blivet instance
        :param ksdata: data parsed from the kickstart file and set in the
                       installation process
        :type ksdata: pykickstart.base.BaseHandler instance
        :param instclass: distribution-specific information
        :type instclass: pyanaconda.installclass.BaseInstallClass
        :param payload: object managing packages and environment groups
                        for the installation
        :type payload: pyanaconda.packaging.dnfpayload.DNFPayload

        """

        # no actions needed in this addon
        pass

    def execute(self, storage, ksdata, instclass, users, payload):
        """
        The execute method that should make changes to the installed system. It
        is called only once in the post-install setup phase.

        :see: setup
        :param users: information about created users
        :type users: pyanaconda.users.Users instance

        """

        hello_file_path = os.path.normpath(getSysroot() + HELLO_FILE_PATH)
        with open(hello_file_path, "w") as fobj:
            fobj.write("%s&#92;n" % self.text)</programlisting>
      </example>
      <para>
        In the above example, the <methodname>setup</methodname> method does nothing; the Hello
        World add-on does not make any changes to the installation runtime environment. The
        <methodname>execute</methodname> method writes stored text into a file created in the target
        system's root (<filename>/</filename>) directory. In RHEL, the <methodname>setup</methodname>
        and <methodname>execute</methodname> methods don't have the payload argument.
      </para>
      <para>
        The most important information in the above example is the amount and meaning of the
        arguments passed to the two new methods; these are described in docstrings within the
        example.
      </para>
      <para>
        The final phase of the data life cycle, as well as the last part of the code needed in a
        module providing Kickstart support, is generating a new Kickstart file, which includes
        values set at installation time, at the end of the installation process as described in
        <xref linkend="sect-anaconda-addon-architecture" />. This is performed by calling the
        <methodname>__str__</methodname> method recursively on the tree-like structure storing
        installation data, which means that the class inherited from
        <classname>AddonData</classname> must define its own <methodname>__str__</methodname> method
        which returns its stored data in valid Kickstart syntax. This returned data must be possible
        to parse again using <systemitem>pykickstart</systemitem>.
      </para>
      <para>
        In the Hello World example, the <methodname>__str__</methodname> method will be similar to
        the following example:
      </para>
      <example id="exam-kickstart-str">
        <title>Defining a __str__ Method</title>
        <programlisting language="Python">    def __str__(self):
        """
        What should end up in the resulting kickstart file, i.e. the %addon
        section containing string representation of the stored data.

        """

        addon_str = "%%addon %s" % self.name

        if self.reverse:
            addon_str += " --reverse"

        addon_str += "&#92;n%s&#92;n%%end&#92;n" % self.text
        return addon_str</programlisting>
      </example>
      <para>
        Once your Kickstart support module contains all necessary methods
        (<methodname>handle_header</methodname>, <methodname>handle_line</methodname>,
        <methodname>setup</methodname>, <methodname>execute</methodname> and
        <methodname>__str__</methodname>), it becomes a valid <application>Anaconda</application>
        add-on. You can continue with the following sections to add support for the graphical and
        text-based user interfaces, or you can continue with <xref
          linkend="sect-anaconda-addon-deploying-testing" /> and test the add-on.
      </para>
    </section>

    <section id="sect-anaconda-addon-gui-support">
      <title>Graphical user interface</title>
      <para>
        This section will describe adding support for the graphical user interface (GUI) to your
        add-on. Before you begin, make sure that your add-on already includes support for Kickstart
        as described in the previous section.
      </para>
      <note>
        <para>
          Before you start developing add-ons with support for the graphical interface, make sure to
          install the <package>anaconda-widgets</package> and
          <package>anaconda-widgets-devel</package> packages, which contain Gtk widgets specific for
          <application>Anaconda</application> such as <systemitem>SpokeWindow</systemitem>.
        </para>
      </note>
      <section id="sect-anaconda-addon-gui-support-basic">
        <title>Basic features</title>
        <para>
          Similarly to Kickstart support in add-ons, GUI support requires every part of the add-on
          to contain at least one module with a definition of a class inherited from a particular
          class defined by the API. In case of graphical support, the only recommended class is
          <classname>NormalSpoke</classname>, which is defined in <ulink
            url="https://github.com/rhinstaller/anaconda/blob/master/pyanaconda/ui/gui/spokes/__init__.py"><filename>pyanaconda.ui.gui.spokes</filename></ulink>.
          As the class name suggests, it is a class for the <emphasis>normal spoke</emphasis> type
          of screen as described in <xref linkend="sect-anaconda-hub-and-spoke" />.
        </para>
        <para>
          To implement a new class inherited from <classname>NormalSpoke</classname>, you must
          define the following class attributes which are required by the API:
        </para>
        <itemizedlist>
          <listitem>
            <para>
              <varname>builderObjects</varname> - lists all top-level  objects from the spoke's
              <filename>.glade</filename> file that should be, with their children objects
              (recursively), exposed to the spoke - or should be an empty list if everything should
              be exposed to the spoke (not recommended)
            </para>
          </listitem>
          <listitem>
            <para>
              <varname>mainWidgetName</varname> - contains the id of the main  window widget
              <footnote>
                <para>
                  an instance of the SpokeWindow widget which is a custom widget
                  created for the Anaconda installer
                </para>
              </footnote>
              as defined in the <filename>.glade</filename> file
            </para>
          </listitem>
          <listitem>
            <para>
              <varname>uiFile</varname> - contains the name of the <filename>.glade</filename> file
            </para>
          </listitem>
          <listitem>
            <para>
              <varname>category</varname> - contains the class of the category the spoke belongs to
            </para>
          </listitem>
          <listitem>
            <para>
              <varname>icon</varname> - contains the identifier of the icon that will be used for
              the spoke on the hub
            </para>
          </listitem>
          <listitem>
            <para>
              <varname>title</varname> defines the title that will be used for the spoke on the hub
            </para>
          </listitem>
        </itemizedlist>
        <para>
          Example module with all required definitions is shown in the following example:
        </para>
        <example id="exam-gui-required-attributes">
          <title>Defining Attributes Required for the Normalspoke Class</title>
          <programlisting language="Python"># will never be translated
_ = lambda x: x
N_ = lambda x: x

# the path to addons is in sys.path so we can import things from org_fedora_hello_world
from org_fedora_hello_world.categories.hello_world import HelloWorldCategory
from pyanaconda.ui.gui.spokes import NormalSpoke

# export only the spoke, no helper functions, classes or constants
__all__ = ["HelloWorldSpoke"]

class HelloWorldSpoke(NormalSpoke):
    """
    Class for the Hello world spoke. This spoke will be in the Hello world
    category and thus on the Summary hub. It is a very simple example of
    a unit for the Anaconda's graphical user interface.

    :see: pyanaconda.ui.common.UIObject
    :see: pyanaconda.ui.common.Spoke
    :see: pyanaconda.ui.gui.GUIObject

    """

    ### class attributes defined by API ###

    # list all top-level objects from the .glade file that should be exposed
    # to the spoke or leave empty to extract everything
    builderObjects = ["helloWorldSpokeWindow", "buttonImage"]

    # the name of the main window widget
    mainWidgetName = "helloWorldSpokeWindow"

    # name of the .glade file in the same directory as this source
    uiFile = "hello_world.glade"

    # category this spoke belongs to
    category = HelloWorldCategory

    # spoke icon (will be displayed on the hub)
    # preferred are the -symbolic icons as these are used in Anaconda's spokes
    icon = "face-cool-symbolic"

    # title of the spoke (will be displayed on the hub)
    title = N_("_HELLO WORLD")</programlisting>
        </example>
        <para>
          The <varname>__all__</varname> attribute is used to export the spoke class, followed by
          the first lines of its definition including definitions of attributes mentioned above. The
          values of these attributes are referencing widgets defined in <ulink
            url="https://github.com/rhinstaller/hello-world-anaconda-addon/blob/master/org_fedora_hello_world/gui/spokes/hello_world.glade"><filename>org_fedora_hello_world/gui/spokes/hello.glade</filename></ulink>
          file.
        </para>
        <para>
          Two other notable attributes are present. The first is <varname>category</varname>, which
          has its value imported from the <classname>HelloWorldCategory</classname> class from the
          <ulink
            url="https://github.com/rhinstaller/hello-world-anaconda-addon/blob/master/org_fedora_hello_world/categories/hello_world.py"><filename>org_fedora_hello_world.categories</filename></ulink>
          module. The <classname>HelloWorldCategory</classname> class will be discussed later, but
          for now, note that the path to add-ons is in sys.path so that things can be imported from
          the <package>org_fedora_hello_world</package> package.
        </para>
        <para>
          The second notable attribute in the example is <varname>title</varname>, which contains
          two underscores in its definition. The first one is part of the <function>N_</function>
          function name which marks the string for translation, but returns the non-translated
          version of the string (translation is done later). The second underscore marks the
          beginning of the title itself and makes the spoke reachable using the
          <keycombo><keycap>Alt</keycap><keycap>H</keycap></keycombo> keyboard shortcut.
        </para>
        <para>
          What usually follows the header of the class definition and the class  attributes
          definitions is the constructor that initializes an instance of the class. In case of the
          <application>Anaconda</application> graphical interface objects there are two methods
          initializing a new instance: the <methodname>__init__</methodname> method and the
          <methodname>initialize</methodname> method.
        </para>
        <para>
          The reason for two such functions is that the GUI objects may be created in memory at one
          time and fully initialized (which can take a longer time) at a different time. Therefore,
          the <methodname>__init__</methodname> method should only  call the parent's
          <methodname>__init__</methodname> method and (for example) initialize non-GUI attributes.
          On the other hand, the <methodname>initialize</methodname> method that is called when the
          installer's graphical user interface initializes should finish the full initialization of
          the spoke. 
        </para>
        <para>
          In the sample Hello World add-on, these two methods are defined as follows (note the
          number and description of the arguments passed to the <methodname>__init__</methodname>
          method):
        </para>
        <example id="exam-gui-init">
          <title>Defining the __init__ and initialize Methods</title>
          <programlisting language="Python">    def __init__(self, data, storage, payload, instclass):
        """
        :see: pyanaconda.ui.common.Spoke.__init__
        :param data: data object passed to every spoke to load/store data
                     from/to it
        :type data: pykickstart.base.BaseHandler
        :param storage: object storing storage-related information
                        (disks, partitioning, bootloader, etc.)
        :type storage: blivet.Blivet
        :param payload: object storing packaging-related information
        :type payload: pyanaconda.packaging.Payload
        :param instclass: distribution-specific information
        :type instclass: pyanaconda.installclass.BaseInstallClass

        """

        NormalSpoke.__init__(self, data, storage, payload, instclass)

    def initialize(self):
        """
        The initialize method that is called after the instance is created.
        The difference between __init__ and this method is that this may take
        a long time and thus could be called in a separated thread.

        :see: pyanaconda.ui.common.UIObject.initialize

        """

        NormalSpoke.initialize(self)
        self._entry = self.builder.get_object("textEntry")</programlisting>
        </example>
        <para>
          Note the <varname>data</varname> parameter passed to the <methodname>__init__</methodname>
          method. This is the in-memory tree-like representation of the Kickstart file where all
          data is stored. In one of the ancestors' <methodname>__init__</methodname> methods it is
          stored in the <varname>self.data</varname> attribute, which allows all other methods in
          the class to read and modify the structure.
        </para>
        <para>
          Because the <classname>HelloWorldData</classname> class has already been defined in <xref
            linkend="sect-anaconda-addon-kickstart-support" />, there already is a subtree in
          <varname>self.data</varname> for this add-on, and its root (an instance of the class) is
          available as <varname>self.data.addons.org_fedora_hello_world</varname>.
        </para>
        <para>
          One of the other things an ancestor's <methodname>__init__</methodname> does is
          initializing an instance of the <classname>GtkBuilder</classname>  with the spoke's
          <filename>.glade</filename> file and storing it as <varname>self.builder</varname>. This
          is used in the  <methodname>initialize</methodname> method to get the
          <classname>GtkTextEntry</classname> used to show and modify the text from the kickstart
          file's %addon section.
        </para>
        <para>
          The <methodname>__init__</methodname> and <methodname>initialize</methodname> methods are
          both important when the spoke is created. However, the main role of the spoke is to be
          visited by an user who wants to change or review the values this spoke shows and sets. To
          enable this, three other methods are available:
        </para>
        <itemizedlist>
          <listitem>
            <para>
              <methodname>refresh</methodname> - called when the spoke is about to be visited; This
              method refreshes the state of the spoke (mainly its UI elements) to make sure that
              current values stored in the <varname>self.data</varname> structure are displayed
            </para>
          </listitem>
          <listitem>
            <para>
              <methodname>apply</methodname> - called when the spoke is left and used to store
              values from UI elements back into the <varname>self.data</varname> structure
            </para>
          </listitem>
          <listitem>
            <para>
              <methodname>execute</methodname> - called when the spoke is left and used to perform
              any runtime changes based on the new state of the spoke
            </para>
          </listitem>
        </itemizedlist>
        <para>
          These functions are implemented in the sample Hello World add-on in the following way:
        </para>
        <example id="exam-gui-refresh-apply-execute">
          <title>Defining the refresh, apply and execute Methods</title>
          <programlisting language="Python">    def refresh(self):
        """
        The refresh method that is called every time the spoke is displayed.
        It should update the UI elements according to the contents of
        self.data.

        :see: pyanaconda.ui.common.UIObject.refresh

        """

        self._entry.set_text(self.data.addons.org_fedora_hello_world.text)

    def apply(self):
        """
        The apply method that is called when the spoke is left. It should
        update the contents of self.data with values set in the GUI elements.

        """

        self.data.addons.org_fedora_hello_world.text = self._entry.get_text()

    def execute(self):
        """
        The excecute method that is called when the spoke is left. It is
        supposed to do all changes to the runtime environment according to
        the values set in the GUI elements.

        """

        # nothing to do here
        pass
          </programlisting>
        </example>
        <para>
          You can use several additional methods to control the spoke's state:
        </para>
        <itemizedlist>
          <listitem>
            <para>
              <methodname>ready</methodname> - determines whether the spoke is ready to be visited;
              if the value is false, the spoke is not accessible (e.g. the <guilabel>Package
                Selection</guilabel> spoke before a package source is configured)
            </para>
          </listitem>
          <listitem>
            <para>
              <methodname>completed</methodname> - determines if the spoke has been completed
            </para>
          </listitem>
          <listitem>
            <para>
              <methodname>mandatory</methodname> - determines if the spoke is mandatory or not (e.g.
              the <guilabel>Installation Destination</guilabel> spoke, which must be always visited,
              even if you want to use automatic partitioning)
            </para>
          </listitem>
        </itemizedlist>
        <para>
          All of these attributes need to be dynamically determined based on the current state of
          the installation process. Below is a sample implementation of these methods in the Hello
          World add-on, which requires some value to be set in the <varname>text</varname> attribute
          of the <classname>HelloWorldData</classname> class:
        </para>
        <example id="exam-gui-ready-completed-mandatory">
          <title>Defining the ready, completed and mandatory Methods</title>
          <programlisting language="Python">    @property
    def ready(self):
        """
        The ready property that tells whether the spoke is ready (can be visited)
        or not. The spoke is made (in)sensitive based on the returned value.

        :rtype: bool

        """

        # this spoke is always ready
        return True

    @property
    def completed(self):
        """
        The completed property that tells whether all mandatory items on the
        spoke are set, or not. The spoke will be marked on the hub as completed
        or uncompleted acording to the returned value.

        :rtype: bool

        """

        return bool(self.data.addons.org_fedora_hello_world.text)

    @property
    def mandatory(self):
        """
        The mandatory property that tells whether the spoke is mandatory to be
        completed to continue in the installation process.

        :rtype: bool

        """

        # this is an optional spoke that is not mandatory to be completed
        return False</programlisting>
        </example>
        <para>
          After defining these properties, the spoke can control its accessibility and completeness,
          but it cannot provide a summary of the values configured within - you must visit the spoke
          to see how it is configured, which may not be desired. For this reason, an additional
          property called <methodname>status</methodname> exists; this property contains a single
          line of text with a short summary of configured values, which can then be displayed in the
          hub under the spoke title.
        </para>
        <para>
          The <methodname>status</methodname> property is defined in the Hello World example add-on
          as follows:
        </para>
        <example id="sect-gui-status">
          <title>Defining the status Property</title>
          <programlisting language="Python">    @property
    def status(self):
        """
        The status property that is a brief string describing the state of the
        spoke. It should describe whether all values are set and if possible
        also the values themselves. The returned value will appear on the hub
        below the spoke's title.

        :rtype: str

        """

        text = self.data.addons.org_fedora_hello_world.text

        # If --reverse was specified in the kickstart, reverse the text
        if self.data.addons.org_fedora_hello_world.reverse:
            text = text[::-1]

        if text:
            return _("Text set: %s") % text
        else:
            return _("Text not set")</programlisting>
        </example>
        <para>
          After defining all properties described in this chapter, the add-on has full support for
          the graphical user interface as well as Kickstart. Note that the example demonstrated here
          is very simple and does not contain any controls; knowledge of Python Gtk programming is
          required to develop a functional, interactive spoke in the GUI.
        </para>
        <para>
          One notable restriction is that each spoke must have its own main window - an instance of
          the <systemitem>SpokeWindow</systemitem> widget. This widget, along with some other
          widgets specific to <application>Anaconda</application>, is found in the
          <package>anaconda-widgets</package> package. Other files required for development of
          add-ons with GUI support (such as Glade definitions) can be found in the
          <package>anaconda-widgets-devel</package> package.
        </para>
        <para>
          Once your graphical interface support module contains all necessary methods you can continue
          with the following section to add support for the text-based user interface, or you can
          continue with <xref linkend="sect-anaconda-addon-deploying-testing" /> and test the add-on.
        </para>
      </section>

      <section id="sect-anaconda-addon-gui-support-advanced">
        <title>Advanced features</title>
        <para>
          The <filename>pyanaconda</filename> package contains several helper and utility functions
          and constructs which may be used by hubs and spokes and which have not been covered in the
          previous section. Most of them are located in <ulink
            url="https://github.com/rhinstaller/anaconda/blob/master/pyanaconda/ui/gui/utils.py"><filename>pyanaconda.ui.gui.utils</filename></ulink>.
        </para>
        <para>
          The <ulink url="https://github.com/rhinstaller/hello-world-anaconda-addon">sample Hello
            World add-on</ulink> demonstrates usage of the <function>englightbox</function> content
          manager which is also used in <application>Anaconda</application>. This manager can put a
          window into a lightbox to increase its visibility and focus it and to prevent users
          interacting with the underlying window. To demonstrate this function, the sample add-on
          contains a button which opens a new dialog window; the dialog itself is a special
          <classname>HelloWorldDialog</classname> inheriting from the
          <classname>GUIObject</classname> class, which is defined in <ulink
            url="https://github.com/rhinstaller/anaconda/blob/master/pyanaconda/ui/gui/__init__.py"><filename>pyanaconda.ui.gui.__init__</filename></ulink>.
        </para>
        <para>
          The <classname>dialog</classname> class defines the <methodname>run</methodname> method
          which runs and destroys an internal Gtk dialog accessible through the
          <varname>self.window</varname> attribute, which is populated using a
          <classname>mainWidgetName</classname> class attribute with the same meaning. Therefore,
          the code defining the dialog is very simple, as demonstrated in the following example:
        </para>
        <example id="exam-gui-advanced-dialog">
          <title>Defining a englightbox Dialog</title>
          <programlisting language="Python">        # every GUIObject gets ksdata in __init__
        dialog = HelloWorldDialog(self.data)

        # show dialog above the lightbox
        with enlightbox(self.window, dialog.window):
            dialog.run()</programlisting>
        </example>
        <para>
          The code above creates an instance of the dialog and then uses the
          <function>enlightbox</function> context manager to run the dialog within a lightbox. The
          context manager needs a reference to the window of the spoke and to the dialog's window to
          instantiate the lightbox for them.
        </para>
        <para>
          Another useful feature provided by <application>Anaconda</application> is the ability to
          define a spoke which will appear both during the installation and after the first reboot
          (in the <application>Initial Setup</application> utility described in <xref
            linkend="sect-firstboot-introduction" />). To make a spoke available in both
          <application>Anaconda</application> and <application>Initial Setup</application>, you must
          inherit the special <classname>FirstbootSpokeMixIn</classname> (or, more precisely, mixin)
          as the first inherited class defined in the <ulink
            url="https://github.com/rhinstaller/anaconda/blob/master/pyanaconda/ui/common.py"><filename>pyanaconda.ui.common</filename></ulink>
          module.
        </para>
        <para>
          If you want to make a certain spoke available <emphasis>only</emphasis> in
          <application>Initial Setup</application>, you should instead inherit the
          <classname>FirstbootOnlySpokeMixIn</classname> class.
        </para>
        <para>
          There are many more advanced features provided by the <package>pyanaconda</package>
          package (like the  <function>@gtk_action_wait</function> and
          <function>@gtk_action_nowait</function> decorators), but they are out of scope of this
          guide. Readers are recommended to go through the <ulink
            url="https://github.com/rhinstaller/anaconda">installer's sources</ulink> for examples.
        </para>
      </section>

    </section>

    <section id="sect-anaconda-addon-tui-support">
      <title>Text User Interface</title>
      <para>
        The third supported interface, after Kickstart and GUI which have been discussed in previous
        sections, <application>Anaconda</application> also supports a text-based interface. This
        interface is more limited in its capabilities, but on some systems it may be the only choice
        for an interactive installation. For more information about differences between the
        text-based and graphical interface and about limitations of the TUI, see <xref
          linkend="sect-anaconda-introduction" />.
      </para>
      <para>
        To add support for the text interface into your add-on, create a new set of subpackages
        under the <filename>tui</filename> directory as described in <xref
          linkend="sect-anaconda-addon-structure" />. 
      </para>
      <para>
        Text mode support in the installer is based on the <systemitem>simpleline</systemitem>
        utility, which only allows very simple user interaction. It does <emphasis>not</emphasis>
        support cursor movement (instead acting like a line printer) nor any visual enhancements
        like using different colors or fonts.
      </para>
      <para>
        Internally, there are three main classes in the <systemitem>simpleline</systemitem> toolkit:
        <classname>App</classname>, <classname>UIScreen</classname> and
        <classname>Widget</classname>. Widgets, which are units containing information to be shown
        (printed) on the screen, are placed on UIScreens which are switched by a single instance of
        the <classname>App</classname> class. On top of the basic elements, there are
        <emphasis>hubs</emphasis>, <emphasis>spokes</emphasis> and <emphasis>dialogs</emphasis>, all
        containing various widgets in a way similar to the graphical interface.
      </para>
      <para>
        For an add-on, the most important classes are <classname>NormalTUISpoke</classname> and
        various other classes defined in the <ulink
          url="https://github.com/rhinstaller/anaconda/tree/master/pyanaconda/ui/tui/spokes"><filename>pyanaconda.ui.tui.spokes</filename></ulink>
        package. All of those classes are based on the <classname>TUIObject</classname> class, which
        itself is an equivalent of the <classname>GUIObject</classname> class discussed in the
        previous chapter. Each TUI spoke is a Python class inheriting from the
        <classname>NormalTUISpoke</classname> class, overriding special arguments and methods
        defined by the API. 
      </para>
      <para>
        Because the text interface is simpler than the GUI, there are only two such arguments:
        <varname>title</varname>, which determines the title of the spoke, and
        <varname>category</varname>, which determines its category (the category name is not
        displayed anywhere, it is only used for grouping). Both have the same meanings as the
        equivalent GUI arguments, described in the previous section.
      </para>
      <para>
        Each spoke is also expected to override several methods, namely
        <methodname>__init__</methodname>, <methodname>initialize</methodname>,
        <methodname>refresh</methodname>,  <methodname>refresh</methodname>,
        <methodname>apply</methodname>,  <methodname>execute</methodname>,
        <methodname>input</methodname>, and  <methodname>prompt</methodname>, and properties
        (<methodname>ready</methodname>, <methodname>completed</methodname>,
        <methodname>mandatory</methodname>, and <methodname>status</methodname>). All of these have
        already been described in <xref linkend="sect-anaconda-addon-gui-support" />.
      </para>
      <para>
        The example below shows the implementation of a simple TUI spoke in the Hello World sample
        add-on:
      </para>
      <example id="exam-tui-normaltuispoke">
        <title>Defining a Simple TUI Spoke</title>
        <programlisting language="Python">    def __init__(self, app, data, storage, payload, instclass):
        """
        :see: pyanaconda.ui.tui.base.UIScreen
        :see: pyanaconda.ui.tui.base.App
        :param app: reference to application which is a main class for TUI
                    screen handling, it is responsible for mainloop control
                    and keeping track of the stack where all TUI screens are
                    scheduled
        :type app: instance of pyanaconda.ui.tui.base.App
        :param data: data object passed to every spoke to load/store data
                     from/to it
        :type data: pykickstart.base.BaseHandler
        :param storage: object storing storage-related information
                        (disks, partitioning, bootloader, etc.)
        :type storage: blivet.Blivet
        :param payload: object storing packaging-related information
        :type payload: pyanaconda.packaging.Payload
        :param instclass: distribution-specific information
        :type instclass: pyanaconda.installclass.BaseInstallClass

        """

        NormalTUISpoke.__init__(self, app, data, storage, payload, instclass)
        self._entered_text = ""

    def initialize(self):
        """
        The initialize method that is called after the instance is created.
        The difference between __init__ and this method is that this may take
        a long time and thus could be called in a separated thread.

        :see: pyanaconda.ui.common.UIObject.initialize

        """

        NormalTUISpoke.initialize(self)

    def refresh(self, args=None):
        """
        The refresh method that is called every time the spoke is displayed.
        It should update the UI elements according to the contents of
        self.data.

        :see: pyanaconda.ui.common.UIObject.refresh
        :see: pyanaconda.ui.tui.base.UIScreen.refresh
        :param args: optional argument that may be used when the screen is
                     scheduled (passed to App.switch_screen* methods)
        :type args: anything
        :return: whether this screen requests input or not
        :rtype: bool

        """

        self._entered_text = self.data.addons.org_fedora_hello_world.text
        return True

    def apply(self):
        """
        The apply method that is called when the spoke is left. It should
        update the contents of self.data with values set in the spoke.

        """

        self.data.addons.org_fedora_hello_world.text = self._entered_text

    def execute(self):
        """
        The excecute method that is called when the spoke is left. It is
        supposed to do all changes to the runtime environment according to
        the values set in the spoke.

        """

        # nothing to do here
        pass

    def input(self, args, key):
        """
        The input method that is called by the main loop on user's input.

        :param args: optional argument that may be used when the screen is
                     scheduled (passed to App.switch_screen* methods)
        :type args: anything
        :param key: user's input
        :type key: unicode
        :return: if the input should not be handled here, return it, otherwise
                 return True or False if the input was processed succesfully or
                 not respectively
        :rtype: bool|unicode

        """

        if key:
            self._entered_text = key

        # no other actions scheduled, apply changes
        self.apply()

        # close the current screen (remove it from the stack)
        self.close()
        return True

    def prompt(self, args=None):
        """
        The prompt method that is called by the main loop to get the prompt
        for this screen.

        :see: pyanconda.ui.tui.simpleline.Prompt

        :param args: optional argument that can be passed to App.switch_screen*
                     methods
        :type args: anything
        :return: text that should be used in the prompt for the input
        :rtype: instance of pyanconda.ui.tui.simpleline.Prompt or None
        """

        return Prompt(_("Enter a new text or leave empty to use the old one: "))</programlisting>
      </example>
      <para>
        It is not necessary to override the <methodname>__init__</methodname> method if it only
        calls the ancestor's <methodname>__init__</methodname>, but the comments in the example
        describe the arguments passed to constructors of spoke classes in an understandable way.
      </para>
      <para>
        The <methodname>initialize</methodname> method sets up a default value for the internal
        attribute of the spoke, which is then updated by the <methodname>refresh</methodname> method
        and used by the <methodname>apply</methodname> method to update Kickstart data. The only
        differences in these two methods from their equivalents in the GUI is the return type of the
        <methodname>refresh</methodname> method (<type>bool</type> instead of <type>None</type>) and
        an additional <varname>args</varname> argument they take. The meaning of the returned value
        is explained in the comments - it tells the application (the <classname>App</classname>
        class instance) whether this spoke requires user input or not. The additional
        <varname>args</varname> argument is used for passing extra information to the spoke when
        scheduled.
      </para>
      <para>
        The <methodname>execute</methodname> method has the same purpose as the equivalent method in
        the GUI; in this case, the method does nothing.
      </para>
      <para>
        Methods <methodname>input</methodname> and <methodname>prompt</methodname> are specific to
        the text interface; there are no equivalents in Kickstart or GUI. These two methods are
        responsible for user interaction.
      </para>
      <para>
        The <methodname>prompt</methodname> method should return an instance of
        <classname>Prompt</classname>. The instance will provide text that will be displayed
        after the content of the spoke is printed. In RHEL, the text is provided directly by the
        <methodname>prompt</methodname> method. After a string is entered in reaction to the
        prompt, this string is passed to the <methodname>input</methodname> method for processing.
        The <methodname>input</methodname> method then processes the entered string and takes action
        depending on its type and value. The above example asks for <emphasis>any</emphasis> value
        and then stores it as an internal attribute (<varname>key</varname>). In more complicated
        add-ons, you typically need to perform some non-trivial actions, such as parse
        <literal>c</literal> as "continue" or <literal>r</literal> as "refresh", convert numbers
        into integers, show additional screens or toggle boolean values.
      </para>
      <para>
        Return value of the <classname>input</classname> class must be either the
        <varname>INPUT_PROCESSED</varname> or <varname>INPUT_DISCARDED</varname> constant (both of
        these are defined in the <ulink
          url="https://github.com/rhinstaller/anaconda/blob/master/pyanaconda/constants_text.py"><filename>pyanaconda.constants_text</filename></ulink>
        module), <emphasis>or</emphasis> the input string itself (in case this input should be
        processed by a different screen).
      </para>
      <para>
        In contrast to the graphical mode, the <methodname>apply</methodname> method is not called
        automatically when leaving the spoke; it must be called explicitly from the
        <methodname>input</methodname> method. The same applies to closing (hiding) the spoke's
        screen, which is done by calling the <methodname>close</methodname> method.
      </para>
      <para>
        To show another screen (for example, if you need additional information which was entered in
        a different spoke), you can instantiate another <classname>TUIObject</classname> and call
        one of the <methodname>self.app.switch_screen*</methodname> methods of the
        <classname>App</classname>.
      </para>
      <para>
        Due to restrictions of the text-based interface, TUI spokes tend to have a very similar
        structure: a list of checkboxes or entries which should be checked or unchecked and
        populated by the user. The previous paragraphs show a way to implement a TUI spoke where the
        its methods handle printing and processing of the available and provided data. However,
        there is a different way to accomplish this using the <classname>EditTUISpoke</classname>
        class from the <ulink
          url="https://github.com/rhinstaller/anaconda/blob/master/pyanaconda/ui/tui/spokes/__init__.py"><filename>pyanaconda.ui.tui.spokes</filename></ulink>
        package. By inheriting this class, you can implement a typical TUI spoke by only specifying
        fields and attributes which should be set in it. The example below demonstrates this:
      </para>     
      <example id="exam-tui-edittuispoke">
        <title>Using EditTUISpoke to Define a Text Interface Spoke</title>
        <programlisting language="Python">class _EditData(object):
    """Auxiliary class for storing data from the example EditSpoke"""

    def __init__(self):
        """Trivial constructor just defining the fields that will store data"""

        self.checked = False
        self.shown_input = ""
        self.hidden_input = ""

class HelloWorldEditSpoke(EditTUISpoke):
    """Example class demonstrating usage of EditTUISpoke inheritance"""

    title = _("Hello World Edit")
    category = HelloWorldCategory

    # simple RE used to specify we only accept a single word as a valid input
    _valid_input = re.compile(r'&#92;w+')

    # special class attribute defining spoke's entries as:
    # Entry(TITLE, ATTRIBUTE, CHECKING_RE or TYPE, SHOW_FUNC or SHOW)
    # where:
    #   TITLE specifies descriptive title of the entry
    #   ATTRIBUTE specifies attribute of self.args that should be set to the
    #             value entered by the user (may contain dots, i.e. may specify
    #             a deep attribute)
    #   CHECKING_RE specifies compiled RE used for deciding about
    #               accepting/rejecting user's input
    #   TYPE may be one of EditTUISpoke.CHECK or EditTUISpoke.PASSWORD used
    #        instead of CHECKING_RE for simple checkboxes or password entries,
    #        respectively
    #   SHOW_FUNC is a function taking self and self.args and returning True or
    #             False indicating whether the entry should be shown or not
    #   SHOW is a boolean value that may be used instead of the SHOW_FUNC
    #
    #   :see: pyanaconda.ui.tui.spokes.EditTUISpoke
    edit_fields = [
        Entry("Simple checkbox", "checked", EditTUISpoke.CHECK, True),
        Entry("Always shown input", "shown_input", _valid_input, True),
        Entry("Conditioned input", "hidden_input", _valid_input,
              lambda self, args: bool(args.shown_input)),
        ]

    def __init__(self, app, data, storage, payload, instclass):
        EditTUISpoke.__init__(self, app, data, storage, payload, instclass)

        # just populate the self.args attribute to have a store for data
        # typically self.data or a subtree of self.data is used as self.args
        self.args = _EditData()

    @property
    def completed(self):
        # completed if user entered something non-empty to the Conditioned input
        return bool(self.args.hidden_input)

    @property
    def status(self):
        return "Hidden input %s" % ("entered" if self.args.hidden_input
                                    else "not entered")

    def apply(self):
        # nothing needed here, values are set in the self.args tree
        pass</programlisting>
      </example>
      <para>
        The auxiliary class <classname>_EditData</classname> serves as a data container which is
        used to store values entered by the user. The <classname>HelloWorldEditSpoke</classname>
        class defines a simple spoke with one checkbox and two entries, all of which are instances
        of the <classname>EditTUISpokeEntry</classname> class imported as the
        <classname>Entry</classname> class). The first one is shown every time the spoke is
        displayed, the second instance is only shown if the first one contains a non-empty value.
      </para>
      <para>
        For more information about the <classname>EditTUISpoke</classname> class, see the comments
        in the above example.
      </para>
    </section>

  </section>

  <section id="sect-anaconda-addon-deploying-testing">
    <title>Deploying and Testing an Anaconda Add-on</title>
    <para>
      As mentioned previously, there are some packages required for development of an Anaconda
      ad-don. In particular, the <package>anaconda-widgets</package> and
      <package>anaconda-widgets-devel</package> packages that contain the widgets, glade
      specifications etc. and the <package>anaconda</package> package that contains the
      <package>pyanaconda</package> Python package (needed for running pylint checks and so on).
    </para>
    <para>
      To test a newly created add-on, you must place it into the installer runtime environment and
      let <application>Anaconda</application> collect the add-on classes and definitions. Add-ons
      are collected from the <filename>/usr/share/anaconda/addons/</filename> directory, which is
      expected to contain your add-ons Python packages (directory trees).
    </para>
    <para>
      The most simple way to load your add-on is to create an identical directory structure
      somewhere on your system (e.g. <filename>~/temp/usr/share/anaconda/addons/</filename>), place
      a copy of your add-on's
      package into it, and then execute the following command: 
    </para>
    <screen><prompt>$</prompt> <command>find . | cpio -c -o | gzip -9 > addon_updates.img</command></screen>
    <para>
      The command creates an archive which can be used as a so-called <firstterm>updates
        image</firstterm>. This image can then be placed on a web server or copied to a USB flash
      drive, and then loaded from the boot menu using the <option>inst.updates=</option> boot
      option. The image will then be loaded and its contents will be used to add or replace any
      files in the installation environment.
      <footnote>
        <para>
          overwriting the files that already exist with the files from the updates image (which is
          how the Anaconda developers use those files for testing patches)
        </para>
      </footnote>
    </para>
    <para>
      For information about boot options, see the <ulink
        url="https://docs.fedoraproject.org/en-US/Fedora/&PRODVER;/html/Installation_Guide/chap-anaconda-boot-options.html">Fedora
        Installation Guide</ulink>.
    </para>
    <indexterm>
      <primary>compose</primary>
    </indexterm>
    <indexterm>
      <primary>spec</primary>
    </indexterm> 
    <para>
      Once an add-on is tested and ready for deployment, you should package it as a Fedora package
      to facilitate the creation of installation images containing your add-on (so-called
      <firstterm>composes</firstterm>). This requires you to write a <firstterm>spec
        file</firstterm> which defines and describes the RPM package.
    </para>
    <para>
      Below is an example of a basic spec file for an add-on:
    </para>
    <example id="exam-addon-specfile">
      <title>Sample RPM Spec File</title>
      <programlisting language="RPM Spec">
Name:           example-anaconda-addon
Version:        0.1
Release:        1%{?dist}
Summary:        Anaconda addon useful for something in the installation process

License:        GPLv2+
URL:            https://git.fedorahosted.org/cgit/example-anaconda-addon.git

Source0:        %{name}-%{version}.tar.gz

BuildArch:      noarch
BuildRequires:  python2-devel
BuildRequires:  anaconda >= 19
Requires:       anaconda >= 19

%description
This is an addon that brings some useful additional functionality to the
Anaconda installer.

%prep
%setup -q

%build

%check
make test

%install
make install DESTDIR=%{buildroot}

%files
%{_datadir}/anaconda/addons/org_fedora_example

%doc COPYING ChangeLog README

%changelog
* Mon Jan 6 2014 Great Author &lt;great.author@example.com&gt; - 0.1-1
- Initial RPM for the example-anaconda-addon
      </programlisting>
    </example>
 
    <indexterm id="Makefile">
      <primary>Makefile</primary>
    </indexterm>

    <para>
      The above spec file makes use of the <command>make</command> utility with the following
      example Makefile: 
    </para>
    <example id="exam-addon-example-makefile">
      <title>Sample Makefile</title>
      <programlisting language="Makefile">
NAME = example-anaconda-addon

VERSION = 0.1

ADDON = org_fedora_example
TESTS = tests

FILES = $(ADDON) &#92;
        $(TESTS) &#92;
        COPYING &#92;
        Makefile &#92;
        README

EXCLUDES = &#92;
        *.pyc

all:
        @echo "usage: make dist"
        @echo "       make test"
        @echo "       make install"
        @echo "       make uninstall"

DISTNAME = $(NAME)-$(VERSION)
ADDONDIR = /usr/share/anaconda/addons/
DISTBALL = $(DISTNAME).tar.gz

install:
        mkdir -p $(DESTDIR)$(ADDONDIR)
        cp -rv $(ADDON) $(DESTDIR)$(ADDONDIR)

uninstall:
        rm -rfv $(DESTDIR)$(ADDONDIR)

dist:
        rm -rf $(DISTNAME)
        mkdir -p $(DISTNAME)
        @if test -d ".git"; &#92;
        then &#92;
                echo Creating ChangeLog &amp;&amp; &#92;
                ( cd "$(top_srcdir)" &amp;&amp; &#92;
                  echo '# Generate automatically. Do not edit.'; echo; &#92;
                  git log --stat --date=short ) > ChangeLog.tmp &#92;
                &amp;&amp; mv -f ChangeLog.tmp $(DISTNAME)/ChangeLog &#92;
                || ( rm -f ChangeLog.tmp ; &#92;
                     echo Failed to generate ChangeLog >&amp;2 ); &#92;
        else &#92;
                echo A git clone is required to generate a ChangeLog >&amp;2; &#92;
        fi
        for file in $(FILES); do &#92;
                cp -rpv $$file $(DISTNAME)/$$file; &#92;
        done
        for excl in $(EXCLUDES); do &#92;
                find $(DISTNAME) -name "$$excl" -delete; &#92;
        done
        tar -czvf $(DISTBALL) $(DISTNAME)
        rm -rf $(DISTNAME)
test:
        PYTHONPATH=. nosetests --processes=-1 -vw tests/
      </programlisting>
    </example>

    <!--
      Which packages are needed? How to deploy and test an Anaconda addon on the running system?
    -->
  </section>

  <section id="sect-addons-welcome">
    <title>Add-ons Welcome</title>
    <para>
      There are many things that could be added to the installer to facilitate installation and
      configuration of the operating system. This guide is intended as a starting point for
      <application>Anaconda</application> add-on development; it is not intended as a comprehensive
      guide showing everything that can be accomplished with add-ons.
    </para>
    <indexterm id="oscap_addon">
      <primary>OSCAP Anaconda Addon</primary>
    </indexterm>
    <para>
      Apart from the trivial Hello World add-on demonstrated in this guide and the <ulink
        url="https://github.com/daveyoung/kdump-anaconda-addon"><application>Kdump</application>
        add-on</ulink> mentioned earlier, you can also use the <ulink
        url="https://github.com/OpenSCAP/oscap-anaconda-addon">OpenSCAP Anaconda Add-on</ulink> as a
      source of additional information, tips and patterns which may be useful in custom add-on
      development.
    </para>
    <indexterm>
      <primary>anaconda-devel-list</primary>
    </indexterm>
    <para>
      Members of the <application>Anaconda</application> development team (and in particular
      Vratislav Podzimek) are always willing to help add-on developers with their questions and
      issues. The best place to ask for help is the <ulink
        url="https://www.redhat.com/mailman/listinfo/anaconda-devel-list">anaconda-devel</ulink>
      mailing list that is read and moderated by the <application>Anaconda</application> developers.
    </para>
    <indexterm>
      <primary>anaconda-patches-list</primary>
    </indexterm>
    <para>
      If you have a request for a new feature to be added into the
      <application>Anaconda</application> codebase or API, or if you discover a bug, you can open
      a pull request (tested and checked with <package>pylint</package>
      <footnote>
        <para>
          to facilitate testing and pylint checks, the <command>make check</command> command may be
          used to run tests and checks with quite effective false-positives handling
        </para>
      </footnote>
      ) at <ulink
        url="https://github.com/rhinstaller/anaconda"><application>Anaconda</application> GitHub
      repository</ulink> for review. Once your pull request is approved, one of the developers
      will merge it.
    </para>

    <para>
      Keep in mind, <emphasis>add-ons and patches welcome!</emphasis>
    </para>
      <!--
          The FAQ section will be added based on the initial feedback and
          actual FAQs
      -->
  </section>

  <xi:include href="Revision_History.xml" xmlns:xi="http://www.w3.org/2001/XInclude" />
  <index />
</article>

